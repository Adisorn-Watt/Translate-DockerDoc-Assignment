# RUN

อ้างอิงจาก [Dockerfile สำหรับคำสั่ง RUN](https://docs.docker.com/engine/reference/builder/#run)

แบ่งคำสั่ง `RUN` ที่ยาวหรือซับซ้อนออกเป็นหลายบรรทัดโดยใช้แบ็กสแลช (/) คั่น เพื่อให้คุณสามารถอ่าน `Dockerfile` ได้อย่างเข้าใจ และสามารถแก้ไขได้ง่ายมากขึ้น

## APT-GET
โดยส่วนมากเราจะใช้คำสั่ง `RUN` เป็นแอปพลิเคชั่นของ `apt-get` เนื่องจากมันได้ทำการติดตั้งอยู่ในแพคเกจ โดยคำสั่ง `RUN apt-get` มีหลายสิ่งที่ควรระมัดระวังในการใช้

หลีกเลี่ยงคำสั่ง `RUN apt-get upgrade` และ `dist-upgrade` เพราะมีแพคเกจที่ "จำเป็น" จำนวนมากที่ไม่สามารถอัพเกรดใน [unprivileged container](https://docs.docker.com/engine/reference/run/#security-configuration) ได้ ถ้าหากว่าแพคเกจนั้นมีเวอชั่นที่เก่าแล้วให้ติดต่อผู้ดูแล หากคุณรู้ว่ามีแพคเกจเฉพาะ `foo` ซึ่งจำเป็นต้องได้รับการอัปเดตให้ใช้ `apt-get install -y foo` เพื่ออัปเดตโดยอัตโนมัติ

ให้ทำการรวม `RUN apt-get update` กับ `apt-get install` ในคำสั่ง `RUN` เดียวกันเสมอ ตัวอย่างเช่น:

```
RUN apt-get update && apt-get install -y \
    package-bar \
    package-baz \
    package-foo
```

ถ้าหากใช้ `apt-get update` เพียงอย่างเดียวใน `RUN` จะทำให้เกิดปัญหาการแคช (caching) นั้นเอง และคำแนะนำที่ให้ใช้ `apt-get install` ก็จะล้มเหลว ตัวอย่างเช่น สมมติว่าคุณมี Dockerfile ดังบรรทัดล่าง:

```
FROM ubuntu:18.04
RUN apt-get update
RUN apt-get install -y curl
```

หลังจากสร้างอิมเมจ เลเยอร์ทั้งหมดจะอยู่ในแคช สมมติว่าคุณจะแก้ไข `apt-get install` ในภายหลังโดยการเพิ่มแพ็คเกจพิเศษดังนี้:

```
FROM ubuntu:18.04
RUN apt-get update
RUN apt-get install -y curl nginx
```

Docker จะเห็นค่าเริ่มต้นกับสิ่งที่แก้ไขแล้ว และนำแคชกลับมาใช้ใหม่จากขั้นตอนก่อนหน้า ผลที่ตามมาคือ `apt-get update` จะ *ไม่* ดำเนินการ เพราะการสร้างนั้นใช้เวอร์ชั่นแคช เนื่องจาก `apt-get update` ไม่ได้ทำงาน การสร้างของคุณอาจจะได้รับแพคเกจ `curl` และ `nginx` ที่ล้าสมัย

การใช้ `RUN apt-get update && apt-get install -y` ทำให้คุณมั่นใจได้ว่า Dockerfile ของคุณได้ทำการติดตั้งแพคเกจเวอร์ชั่นล่าสุดแล้ว โดยไม่มีการเข้ารหัสหรือการแทรกแซงของตัวโปรแกรม เทคนิคนี้เรียกว่า "การป้องกันแคช (cache busting)" นอกจากนี้ยังสามารถใช้แคชได้ โดยระบุเวอร์ชั่นของแพคเกจ สิ่งนี้เรียกว่าการตรึงเวอร์ชั่น (version pinning) ดังตัวอย่างเช่น:

```
RUN apt-get update && apt-get install -y \
    package-bar \
    package-baz \
    package-foo=1.3.*
```

การตรึงเวอร์ชั่นจะบังคับให้สร้างแบบใช้เวอร์ชั่นเฉพาะ โดยไม่คำนึงถึงสิ่งที่อยู่ในแคช เทคนิคนี้ยังสามารถลดความล้มเหลวเนื่องจากการเปลี่ยนแปลงแบบคาดไม่ถึงในแพคเกจที่จำเป็นอีกด้วย
ด้านล่างนี้เป็นรูปแบบคำสั่ง `RUN` ที่ดี ซึ่งแสดงให้เห็นถึงคำแนะนำ `apt-get` ทั้งหมด

```
RUN apt-get update && apt-get install -y \
    aufs-tools \
    automake \
    build-essential \
    curl \
    dpkg-sig \
    libcap-dev \
    libsqlite3-dev \
    mercurial \
    reprepro \
    ruby1.9.1 \
    ruby1.9.1-dev \
    s3cmd=1.1.* \
 && rm -rf /var/lib/apt/lists/*
```

`s3cmd` คือ argument ระบุเวอร์ชั่น `1.1.*` หากอิมเมจนั้นเคยใช้เวอร์ชั่นเก่า จะเป็นหนึ่งในเหตุผลที่ทำให้เกิดการแคช `apt-get update` และทำให้มั่นใจได้ว่าจะติดตั้งเวอร์ชั่นใหม่ การแสดงรายการแพคเกจในแต่ละบรรทัดนั้นสามารถป้องกันข้อผิดพลาดในกรณีเกิดการซ้ำกันของแพคเกจได้

นอกจากนี้เมื่อคุณล้างแคช apt โดยการลบ `/var/lib/apt/lists` มันจะลดขนาดอิมเมจ เนื่องจากแคช apt ไม่ได้ถูกจัดเก็บในเลเยอร์ ตั้งแต่คำสั่ง `RUN` เริ่มจาก `apt-get update` และแคชแพคเกจจะรีเฟรชก่อน `apt-get install` เสมอ

>อิมเมจ Debian และ Ubuntu จะ [ทำงาน `apt-get clean` โดยอัตโนมัติ](https://github.com/moby/moby/blob/03e2923e42446dbb830c654d0eec323a0b4ef02a/contrib/mkimage/debootstrap#L82-L105) ดังนั้นจึงไม่จำเป็นต้องใช้การร้องขอ

## USING PIPES

บางคำสั่ง `RUN` ขึ้นอยู่กับความสามารถในการ pipe ผลลัพธ์ของคำสั่งหนึ่งไปยังอีกคำสั่งหนึ่ง โดยใช้อักขระ pipe (`|`) ดังตัวอย่างต่อไปนี้:

```
RUN wget -O - https://some.site | wc -l > /number
```

Docker จะเรียกใช้คำสั่งเหล่านี้โดยใช้ล่าม `/bin/sh -c` ซึ่งจะประเมินรหัสทางออกของการดำเนินการครั้งสุดท้ายใน pipe เพื่อตัดสินใจเลือกเส้นทางที่ประสบความสำเร็จเท่านั้น จากในตัวอย่างข้างบนเป็นขั้นตอนการสร้างที่สำเร็จ และสร้างอิมเมจใหม่เนื่องจากคำสั่ง `wc -l` สำเร็จ ถึงแม้ว่าคำสั่ง `wget` จะไม่สำเร็จก็ตาม

หากคุณต้องการให้คำสั่งล้มเหลวเนื่องจากข้อผิดพลาดที่เกิดจากขั้นตอนอื่นๆใน pipe ให้เตรียม `set -o pipefail &&` เพื่อให้แน่ใจว่าข้อผิดพลาดที่ไม่คาดคิดจะป้องกันการสร้างจากความสำเร็จแบบไม่ได้ตั้งใจ ตัวอย่างเช่น:

```
RUN set -o pipefail && wget -O - https://some.site | wc -l > /number
```

>### * เซลล์บางตัวไม่รองรับตัวเลือก -o pipefail
>ในกรณีเช่น `dash` เซลล์บนอิมเมจที่ใช้ Debian จะพิจารณาใช้รูปแบบ *exec* ของ `RUN` เพื่อเลือกเซลล์ที่รองรับตัวเลือก `pipefail` ดังตัวอย่าง:
>```Docker 
> RUN ["/bin/bash", "-c", "set -o pipefail && wget -O - https://some.site | wc -l > /number"]
>```
>
